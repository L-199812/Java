/**
 * @Auther King
 * @Description:
 */

// 多态：在程序里面就是不同对象调用一个方法会产生不同的状态和行为
// 多态条件：继承、重写、指向子类对象的父类指针（引用）去调用重写的方法
// 重写就是子类重写父类的同名函数，函数签名要一样，重载是同级别为了满足不同的输入参数，重载的条件：函数名同，参数不同（类型、顺序、个数），返回值不影响
// private、final(密封方法)、static修饰的方法不能重写
// 返回值可以不一样，但是要求不一样的返回值之间要构成子类父类的关系
// 构造方法也不能重写
// java里面重写的函数一般用@override修饰，idea里面可以生成重写的函数


// 组合就是类对象为属性类型，继承和组合都是一种思想，可以提高代码的复用性
// 重写对于软件升级也是很有好处的

// 静态绑定：也称为早绑定，编译的时候根据你传入的参数能够确定你调用哪个方法，这种就叫做早绑定
// 动态绑定：也称为后期绑定，编译的时候不能确定方法的行为，需要等到程序运行时，才能确定具体调用哪个类的方法


// 向上转型 c++父类指针指向子类对象，java是把子类对象的引用给父类引用，相当于提取共性，将子类对象转为父类对象了
// 父类引用可以接收任何类型的子类对象，就像狗是动物，猫是动物，动物这个父类可以接收猫和狗实例化的子类的对象
// 可以直接赋值发生向上造型Animal animal = new dog(); 也可以函数传参实现，就是型参是父类，外面调用的时候是传入子类对象,也可以直接返回子类对象,但是返回值类型是父类
// 向上转型之后不能调用子类的特有方法

// 向下转型会导致底层内存越界,有的东西父类里面根本没有定义

// 多态的可扩展性很强
// 为什么要指向子类对象的父类指针,直接子类对象调用不行吗,这是因为很多库的源码已经在调用了很多方法了,我们不能去更改源码
//  用指向子类对象的父类指针是一种设计规则,是为了规避源码不更改的问题,是让源码也可以有多态的一种方法

//  圈复杂度就是if\while等条件判别的重数
//  属性没有多态性质\构造方法没有多态性
public class class5 {

}
